package generator

import (
	"bytes"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/4Sigma/rum/internal/config"
)

// TemplateInfo holds information about a discovered template.
type TemplateInfo struct {
	FileName   string // Original filename: "template-1.html.tmpl"
	ConstName  string // PascalCase name: "Template1"
	SourcePath string // Relative path from source
}

// TemplatesGenerator generates Go code for template management.
type TemplatesGenerator struct {
	config *config.TemplatesConfig
}

// NewTemplatesGenerator creates a new template generator.
func NewTemplatesGenerator(cfg *config.TemplatesConfig) *TemplatesGenerator {
	return &TemplatesGenerator{config: cfg}
}

// Generate scans template sources and generates the output file.
func (g *TemplatesGenerator) Generate() error {
	var allTemplates []TemplateInfo

	for _, source := range g.config.Sources {
		templates, err := g.scanSource(source)
		if err != nil {
			return fmt.Errorf("scanning source %s: %w", source.Path, err)
		}
		allTemplates = append(allTemplates, templates...)
	}

	if len(allTemplates) == 0 {
		return fmt.Errorf("no templates found in configured sources")
	}

	// Validate templates syntax
	if err := g.validateTemplates(allTemplates); err != nil {
		return err
	}

	// Generate the output file
	return g.generateFile(allTemplates)
}

// scanSource scans a template source directory for matching files.
func (g *TemplatesGenerator) scanSource(source config.TemplateSource) ([]TemplateInfo, error) {
	var templates []TemplateInfo

	err := filepath.WalkDir(source.Path, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}

		matched, err := filepath.Match(source.Pattern, d.Name())
		if err != nil {
			return err
		}
		if !matched {
			return nil
		}

		templates = append(templates, TemplateInfo{
			FileName:   d.Name(),
			ConstName:  toPascalCase(d.Name()),
			SourcePath: path,
		})
		return nil
	})

	return templates, err
}

// validateTemplates checks template syntax by parsing them.
func (g *TemplatesGenerator) validateTemplates(templates []TemplateInfo) error {
	var errs []error

	for _, t := range templates {
		content, err := os.ReadFile(t.SourcePath)
		if err != nil {
			errs = append(errs, fmt.Errorf("reading %s: %w", t.SourcePath, err))
			continue
		}

		_, err = template.New(t.FileName).Parse(string(content))
		if err != nil {
			errs = append(errs, fmt.Errorf("parsing %s: %w", t.SourcePath, err))
		}
	}

	if len(errs) > 0 {
		return fmt.Errorf("template validation failed:\n%v", errs)
	}
	return nil
}

// generateFile creates the generated Go file.
func (g *TemplatesGenerator) generateFile(templates []TemplateInfo) error {
	// Ensure output directory exists
	outputDir := filepath.Dir(g.config.OutputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Build embed patterns for each source
	var embedPatterns []string
	for _, source := range g.config.Sources {
		pattern := filepath.Join(source.Path, source.Pattern)
		embedPatterns = append(embedPatterns, pattern)
	}

	data := struct {
		Package       string
		Templates     []TemplateInfo
		Sources       []config.TemplateSource
		EmbedPatterns []string
	}{
		Package:       g.config.OutputPackage,
		Templates:     templates,
		Sources:       g.config.Sources,
		EmbedPatterns: embedPatterns,
	}

	var buf bytes.Buffer
	if err := outputTemplate.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	if err := os.WriteFile(g.config.OutputFile, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("writing output file: %w", err)
	}

	fmt.Printf("Generated %s with %d templates\n", g.config.OutputFile, len(templates))
	return nil
}

// toPascalCase converts a filename like "template-1.html.tmpl" to "Template1HtmlTmpl"
func toPascalCase(s string) string {
	// Remove extension parts and convert
	s = strings.TrimSuffix(s, ".tmpl")
	s = strings.TrimSuffix(s, ".html")
	s = strings.TrimSuffix(s, ".txt")

	// Replace separators with spaces for word detection
	re := regexp.MustCompile(`[-_.]`)
	s = re.ReplaceAllString(s, " ")

	// Title case each word and join
	words := strings.Fields(s)
	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])
		}
	}

	return strings.Join(words, "")
}

var outputTemplate = template.Must(template.New("output").Parse(`// Code generated by rum. DO NOT EDIT.
//go:generate rum gen

package {{.Package}}

import (
	"embed"

	rumtpl "github.com/4Sigma/rum/template_manager"
)

{{range .EmbedPatterns}}//go:embed {{.}}
{{end}}var templatesFS embed.FS

// TemplateName is a type-safe template identifier.
type TemplateName = rumtpl.Name

const (
{{- range .Templates}}
	{{.ConstName}} TemplateName = "{{.FileName}}"
{{- end}}
)

// Manager is the template manager instance.
var Manager *rumtpl.Manager

func init() {
	var err error
{{- range $i, $src := .Sources}}
	{{- if eq $i 0}}
	Manager, err = rumtpl.NewManagerFromEmbed(templatesFS, "{{$src.Path}}", "{{$src.Pattern}}")
	{{- else}}
	// Additional source: {{$src.Path}}
	// Note: Multiple sources require merging - extend Manager if needed
	{{- end}}
{{- end}}
	if err != nil {
		panic("rum: failed to initialize template manager: " + err.Error())
	}
}
`))
